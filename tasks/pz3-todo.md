# ПЗ3 - создание todo

## Домашнее задание:

Книга "Python К вершинам мастерства". Глава 5 (стр. 170-197)

Необходимо усвоить:

* функция-объект в чем суть, особенности
* анонимные функции как и когда
* пользовательские вызываемые типы
* позиционные и чисто именованные параметры
* аннотация (вопрос где применяется в современном python?)

Для лучшего понимания происходящего прочесть необходимо еще Главу 6.

Для понимания работы с классами в Python прочесть Главы 26-30 (Марк Лутц 5-е издание, том 2)

На википедии про формат json.

#### Алгоритмические задачи:

Напишите код, решающий задачу, оцените сложность предложенного вам алгоритма (описание, как была подсчитана сложность нужно написать в комментариях к коду):

* Вы забираетесь по лестнице. Длина лестницы - *n* ступенек. Каждый раз вы можете подниматься на 1 или 2 ступеньки. Сколько существует уникальных способов достичь вершины лестницы?

  **Пример**: n = 2

  Объяснение: Существует два способа 

   - 1 двойной шаг
   - 2 одинарных шага

  **Пример:** n = 3

  Объяснение: Существует 3 способа

  * 1, 1, 1 - три одинарных шага
  * 1, 2 - 1 одинарный шаг и 1 двойной шаг
  * 2, 1 - 1 двойной шаг и 1 одинарный

  Шаблон кода:

  ```python
  class Solution:
      """
      Функция принимает на вход n (int)
      Возвращает int
      """
      def climb_stairs(self, n):
  ```

* Напишите функцию, разворачивающую строку. На входе строка будет представлена массивом символов. Вы должны реализовать модификацию массива in-place, задействуя O(1) дополнительной памяти.

  **Пример**: s = ["h","e","l","l","o"]

  Результат: ["o","l","l","e","h"]

  **Пример:** s = ["H","a","n","n","a","h"]

  Результат:  ["h","a","n","n","a","H"]

  Шаблон кода:

  ```python
  class Solution:
      """
      На входе массив
      Возвращаемое значение: нет
      """
      def reverse_string(self, s)
  ```

* Дан массив чисел nums, и целевое значение target, верните индексы двух чисел в массиве, котоыре в сумме дают target. гарантируется, что  существует только одно решение и нельзя использовать один и тот же элемент массива дважды. 

  **Пример**: nums = [2,7,11,15], target = 9

  Объяснение:

  ```
  nums[0] + nums[1] == 9, возвращаем [0, 1]
  ```

  **Пример:** nums = [3,2,4], target = 6

  Объяснение:

  ```
  nums[1] + nums[2] == 6, возвращаем [1, 2]
  ```

  Шаблон кода:

  ```python
  class Solution:
      """
      На вход массив чисел и целевое значение
      На выходе массив из двух индексов
      """
      def two_sum(self, nums, target):

## Рассматриваемые вопросы

1. Базовое понимание классов
2. Базовая обработка исключений
3. Знакомство с  f-строками
4. Базовое использование  pylint (+ встроенный ангализатор кода от  Pycharm)
5. Переход к объявлению функции, поиск, замена, горяче клавиши
6. docstring

## Ход работы

Создаем туду приложение. Необходимо определиться с форматом хранения данных, а также функциями записи и удаления данных. 
Изначальная цель - "чтобы работало"

Для начала сделаем просто список задач, куда можно добавлять задачи, а также удалять задачи 

1. Создаем проект на гитворке

2. Клонируем его

3. Создаем гитигнор, добавляем туда idea

4. Реализуем стандартный мэйн, который уже делали, и про который было дз 

   ```python
   def main():
       pass
   
   
   if __name__ == '__main__':
       main()
   ```

5. Реализуем функции создания туду листа, добавления туда записей и удаления записей. Данные будем хранить в json.  (зачастую делают вообще без функций. и это совсем плохо. по сути многие так делали на долгосроке по бос (ну те два человека, которые делали его сами))

   Создание листа. Функция создающая пустой туду лист. Функция принимает на вход путь до создаваемого туду листа, а также имя туду листа. Показать как переходить к объявлению функции dump.

   ```python
   def create_todo_list(path_todo, todo_name):
       with open(path_todo, "w") as todo_file:
           json.dump(
               {"name": todo_name},
               todo_file,
               sort_keys=True,
               indent=4,
           )
   ```

   Добавление тудушки. Функция принимает на вход существующий туду лист, а также запись, которую необходимо добавить. Осуществляем считывание существующих задач. Добавляем новую задачу. Записываем обновленный список задач в файл.

   ```python
   def add_todo(path_todo, new_todo):
       with open(path_todo, 'r') as todo_file:
           data = json.load(todo_file)
   
       name = data["name"]
       todos = data["todos"]
       
       todos.append(new_todo)
       
       new_data = {
           "name": name,
           "todos": todos,
       }
   
       with open(path_todo, "w", encoding='utf-8') as todo_file:
           json.dump(
               new_data,
               todo_file,
               sort_keys=True,
               indent=4,
               ensure_ascii=False,
           )
   ```

   Удаление тудушки. Функция принимает на вход существующий туду лист и индекс записи, которую нужно удалить. Осуществляем считывание данных. Удаляем по индексу. Записываем обновленный список задач в файл.

   ```python
   def remove_todo(path_todo, index):
       with open(path_todo, 'r') as todo_file:
           data = json.load(todo_file)
       name = data["name"]
       todos = data["todos"]
   
       todos.remove(todos[index])
   
       new_data = {
           "name": name,
           "todos": todos,
       }
   
       with open(path_todo, "w", encoding='utf-8') as todo_file:
           json.dump(
               new_data,
               todo_file,
               sort_keys=True,
               indent=4,
               ensure_ascii=False,
           )
   ```

6. Запустим пайлинт (на дом - прочитать фак по пайлинту более подробный). Обязательно нужно обращать внимание на сообщения от пайлинта и исправлять их.

   ```bash
   pylint main.py
   ```

7. Первый рефакторинг. Что не устраивает? Например, дублирующиеся куски кода в функциях добавления и удаления. И практически полное дублирование в функции создания. (Цель достичь сингл респонсибилити. одна сущность - одна ответственность). Еще? запишем найденные проблемы.

   Вынесем код, отвечающий за записи json в файл в отдельную функцию.

   ```python
   def update_todo(path_todo, new_data):
       with open(path_todo, "w", encoding='utf-8') as todo_file:
           json.dump(
               new_data,
               todo_file,
               sort_keys=True,
               indent=4,
               ensure_ascii=False,
           )
   ```

   Следующий кусок кода, который также одинаков для обоих операций - парсинг существующей тудушки. 

   ```python
   def parse_todo(path_todo):
       with open(path_todo, 'r') as todo_file:
           data = json.load(todo_file)
       return data
   
   ```

   Здесь же поговорим про базовую обработку исключений. 

   В приведенном выше коде потенциально много проблем. А что если неверно указан путь до файла с туду листом, а что если нет доступа на запись, а что если...? Проверим, что будет, если в программу подать несуществующий путь. Очевидно, программа завершится некорректно с исключением.  И это не есть хорошо.

   ```python
   def parse_todo(path_todo):
       try:
           with open(path_todo, 'r') as todo_file:
               data = json.load(todo_file)
           return data
       except FileNotFoundError as e:
           print(f"{e}")
           # или свое исключение
           print(f"Не существует такой тудушки: {path_todo}")
           sys.exit(1)
   ```

   И еще одна причина, почему мы вынесли код в отдельную функцию. В любой момент может измениться структура туду, будет не json, а csv. Все функции добавления, удаления и др. умеют работать с одним форматом, а непосредственно задача парсинга будет лежать вот на этой функции. 

   Захотели обработать исключение, также во все функции бы пришлось добавлять обработку по сути одного и того же исключения. Приводит к непомерно большому увеличению кода, уменьшает читабельность, вырастает вероятность сделать ошибку. Как мы увидим далее, очень разухабистую функцию сложно тестировать. 

8. Какие еще понадобятся функции? Переименовать тудупроект, изменить тудушку, отметить как сделанную, поиск по туду и другие. Вырисовывается некий объект - тудушка с определёнными свойствами - путь, название, ... - в будущем с некими настройками, с которым мы хотим производить действия, описанные выше. Если мы будем продолжать писать функции, то во многие из них придется передавать одни и те же аргументы - общие для всей туду свойства.

   В таком случае эту сущность с общими свойствами уместно вынести в класс.

   Получаем следующий код:
   
   ```python
   class TodoJournal:
       def __init__(self, path_todo, name):
           self.path_todo = path_todo
           self.name = name
   
       def create(self):
           with open(self.path_todo, "w", encoding='utf-8') as todo_file:
               json.dump(
                   {"name": self.name, "todos": []},
                   todo_file,
                   sort_keys=True,
                   indent=4,
                   ensure_ascii=False,
               )
   
       def add_entry(self, new_entry):
           data = self._parse()
   
           name = data["name"]
           todos = data["todos"]
   
           todos.append(new_entry)
   
           new_data = {
               "name": name,
               "todos": todos,
           }
   
           self._update(new_data)
   
       def remove_entry(self, index):
           data = self._parse()
           name = data["name"]
           todos = data["todos"]
   
           todos.remove(todos[index])
   
           new_data = {
               "name": name,
               "todos": todos,
           }
   
           self._update(new_data)
   
       def _update(self, new_data):
           with open(self.path_todo, "w", encoding='utf-8') as todo_file:
               json.dump(
                   new_data,
                   todo_file,
                   sort_keys=True,
                   indent=4,
                   ensure_ascii=False,
               )
   
       def _parse(self):
           try:
               with open(self.path_todo, 'r') as todo_file:
                   data = json.load(todo_file)
               return data
           except FileNotFoundError as error:
               print(f"{error}")
               # или свое исключение
               print(f"Не существует такой тудушки: {self.path_todo}")
               sys.exit(1)
   
   ```

   Учимся писать докстринг. Зачем это. (на дом - задокументировать весь написанный код)
   
   Какие еще есть предложения по улучшению? Какие еще могут быть ошибки? Подумать про функцию создания туду. 

### Самостоятельная работа: 

1. Обработка исключительных ситуаций, которые обсудили выше.
2. Какие еще есть предложения по улучшению? Какие еще могут быть ошибки? Подумать про функцию создания туду. Может что-то внести в конструктор?



