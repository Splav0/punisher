# ПЗ4 - todo

Проект должен находиться в том состоянии, к которому дошел преподаватель на предыдущем пз + реализованные части дз.

## Домашнее задание

**Важно**: всю работу с кодом необходимо производить с использованием механизма ишьсов и создания веток. Перед каждым коммитом необходимо запускать pylint.

1. Задокументировать все функции.
2. Обработать проблемные места и исключения, которые обсудили (вести разработку с использованием ишью трекера гитлаба и для каждого ишью - отдельная ветка).
3. Обработать случаи, когда осуществляется попытка создать тудушку, а такая есть. И наоборот обработат случай, когда осуществляется попытка записи не существующую туду.
4. Написать тесты для функций \_\_len\_\_, add_entry, remove_entry. 
5. Прочесть про тестирование [Часть 1](https://habr.com/en/post/448782/), [Часть 2](https://habr.com/en/post/448788/), [Часть 3](https://habr.com/en/post/448786/), [Часть 4](https://habr.com/en/post/448792/)
6. [Цена ошибки](https://habr.com/en/company/pvs-studio/blog/307788/)
7. Реализовать магический метод для возможности итерации по записям тудушки. 
8. После прочтения материалов по тестам отрефакторить тесты.
9. Добавить в тесты игнорирование замечаний от pylint.

## План (для преподавателя)

1. Долг с первого пз по исключениям и docstring. (Показать тракт: создания ишью-> создания ветки-> кодинг-> закрытия ишью -> удаление ветки) 
2. Вспомнить что было на 1 пз
3. Обсудить какие проблемы есть в программе (исключения + рефакторинг), записать. 
4. Сделать функцию создания тудушки статической. 
5. Продолжение  рефакторинга. Внести в конструктор поле entities(записи) и реализовать магические методы. len, iterate (собственно продемонстировать что наш класс пользовательский тип и по нему нельзя просто так итерироваться).
6. Начать изучение тестов. (протестировать одну простую функцию, с моками и с фикстурами)

## Рассматриваемые вопросы:

1. Любовь к коммитам.
2. Рефакторинг.
3. Статические методы класса.
4. Реализация магических методов для пользовательского типа данных.
5. Основы pytest.
6. Написание readme.md и для чего он нужен.
7. sublime merge

## Ход работы

### Рефакторинг кода

Рефакторинг (переработка) кода — это процесс преобразования внутренней структуры кода, который призван облегчить его понимание и читабельность.
Оптимизация — это процесс переработки внутренней структуры кода с целью увеличения его производительности. При оптимизации читаемость кода
может даже ухудшиться.
Реинжиниринг — это процесс полного переписывания некоторого блока кода. При реинжиниринге может измениться и работа некоторого блока кода.
**Когда нужен рефакторинг?**

* Сложная архитектура системы;
* Использование объектов, затрудняющих понимание системы;
* Упрощение схем наследования;
* Преобразование процедурного кода в объектно-ориентированный.

**Признаки, отличающие код, которому срочно нужен рефакторинг и способы решения.**

* дублирование кода; Решение:
  * выделение повторяющегося кода в функции;
  * если код дублируется в разных подклассах, перенос дублирующегося кода в базовый класс;
  * если же базового класса нет, создать родительский класс дляподклассов с дублиующимся кодом.
* длинные методы; Решение:
  * деление методов на логические блоки;
  * выделение общих переменных блоков в качестве аргументов.
* большие классы (слишком большой функционал); Решение:
  * делить на более мелкие фрагменты.
* длинные списки параметров; Решение:
  * выделение параметров в отдельный объект;
  * передача объекта, содержащего часть параметров, в виде параметра.
* «жадные» функции (чрезмерное использование одним классом методов другого); Решение:
  * перенос методов из одного класса в другой.
* избыточные временные переменные; Решение:
  * код, который используется в исключительных случаях вынести в отдельный класс;
  * при необходимости обращаться к объекту этого класса.
* классы данных (класс содержит только поля без методов); Решение:
  * вместо такого класса использовать объект-контейнеры (например, словарь).
* не сгруппированные данные (используется большое количество связанных переменных и функций). Решение:
  * следует выделять такие переменные и функции в класс;
  * переименование переменных для повышения понятности кода.

**Рефакторинг функции создания тудушки.**

Эту функцию необходимо сделать статической.

В итоге функция будет иметь следующий вид:

```python
@staticmethod
def create(filename, name):
    with open(filename, "w", encoding='utf-8') as todo_file:
        json.dump(
            {"name": name, "todos": []},
            todo_file,
            sort_keys=True,
            indent=4,
            ensure_ascii=False,
        )
```

И вызываться:

```python
TodoJournal.create("./test", "test2")
```

**Магические методы** (Показать на полном тракте работы с gitlab) (sublime)

Что характеризует каждую тудушку кроме пути к ней? Чем мы постоянно оперируем? (записи)

Какой бы функционал хотели? Как можно определить количество записей в тудушке? Чтобы искать, например по записям (задачи на итерирование)?

Возвращаясь к первым вопросам, необходимо внести записи как сущность в конструктор класса.

```python
    def __init__(self, path_todo):
        self.path_todo = path_todo
        # todo отрефакторить двойной вызов _parse (поменять структуру возвращаемых данных?) 
        self.name = self._parse()["name"]
        self.entries = self._parse()["todos"]
```

Обсудить сложности тестрования текущих функций (мокинг открытия). (хороший код - простые тесты)

Определим магический метод \_\_len\_\_:

```python
    def __len__(self):
        return len(self.entries)
```

**Дома**:

1. реализовать возможность итерирования по записям в тудушке. (магические методы iter, next) Должен работать следующий код: 

   ```python
   todo = TodoJournal(...)
   for entry in todo:
       print(entry) # на экран выводятся все записи в тудушке
   ```

2. Реализовать возможность индесирования записей (магический метод \_\_getitem\_\_). Должен работать следующий код:

   ```python
   todo = TodoJournal(...)
   print(todo[0]) # из тудушки выведется на экран запись с индексом 0
   ```

**Очередной рефакторинг добавления и удаления:**

Теперь, можем каждый раз при добавлении и удалении записей не считывать содержимое файла.

Код функции добавления будет иметь следующий вид:

```python
def add_entry(self, new_entry):
    self.entries.append(new_entry)
    new_data = {
        "name": self.name,
        "todos": self.entries,
    }
    self._update(new_data)
```

**Дома** аналогичным образом отрефакторить функцию удаления записи.

**Тестирование кода**

При каждом изменении функции - дописывании функционала или рефакторинге, что мы далаем? Мы запускаем измененную функцию, чтобы проверить, что отрабатывает ожидаемым образом и ничего не сломалось. И так каждый раз. При увеличении проекта желание что-то трогать, что-то рефаторить уменьшается, так как сложность проверки работоспособности увеличивается, а уверенности, что изменения не затронули программу становится все меньше.

Некоторые аспекты тестирования (тут же про цену ошибки - космос, [медицина](https://habr.com/ru/company/pvs-studio/blog/307788/)):

* самодокументация;
* легче искать ошибку;
* спокойный сон после деплоя;
* после изменения кода не нужно вручную проверять, а не сломалось ли чего;
* легкость написания тестов - скорее всего хороший код и наоборот;
* через тесты удобнее отлаживать программу.

Для тестирования кода в Python как правило используется библиотека pytest.

Сразу начнем правильно организовывать хранение тестов. В проекте необходимо создать католог  tests.  Если проект сложный, то обычно создаются еще различные подкаталоги, но сейчас ограничимся одним каталогом.

Подробности организации кода в проекте будем обсуждать далее, но сделаем небольшую логичную реорганизацию **(через механизм ишьюсов)**. Уже создан каталог для тестов. Создадим каталог для исходных кодов -  src,  переименуем файл main.py в TodoJournal.py (как название класса), добавим в каждый каталог файл \_\_init\_\_.py.

Проект будет иметь следующую структуру:

python-todo

 - src
   	- TodoJournal.py
    - \_\_init\_\_.py
 - tests 
   	- test_todo_journal.py
    - \_\_init\_\_.py

Тестирование правильности инициализации объекта класса. Проверяем, что после инициализации в соответствующих полях лежат ожидаемые значения.  Для создания тестовых файлов в каталоге tests создадим каталог data.

```python
from src.TodoJournal import TodoJournal

def test_init():
    """Проверка корректности инициализации TodoJournal"""
    # TODO проблема. чтобы сейчас протестировать нужно знать путь до тудушки, ее имя.
    expected_entries = []
    expected_name = "test_todo"

    todo = TodoJournal("data/test_todo")
    entries = todo.entries
    name = todo.name

    assert entries == expected_entries
    assert name == expected_name
```

В базовом виде pytest запускается:

```bash
pytest
```

**Дома** ознакомиться с особенностями запуска pytest и с особенностями конфигурации pytest.ini

Для измерения процентов покрытия кода тестами используется утилита coverage. Ее можно запускать через командную строку.  **Дома** научиться запускать coverage через командную строку. 

**Важно**: процент покрытия тестами не является маркером протестированности программы.

Однако более наглядное представление дает плагин встроенный в  Pycharm. Pytest также можно запускать с использованием Pycharm. Для его конфигурации необходимо зайти в настройки Pycharm ->Tools->Python Integrated Tools, в разделе Testting выбрать pytest. После этого можно запускать тесты и мерить покрытие из графического интерфейса.

После прочтения серии статей продолжим писать более сложные тесты.

В нашем проекте уже появилась первая сущность, которая нужна стороннему пользователю вашей библиотеки - тесты и как их запускать.

Добавим в проект readme файл. 



