# pz7-todo

## Домашнее задание

* [научиться](https://stackoverflow.com/questions/9339429/what-does-cherry-picking-a-commit-with-git-mean) применять cherry pick в командной строке;
* Ознакомиться со [спецификацией](https://specifications.freedesktop.org/basedir-spec/basedir-spec-0.6.html) xdg base directory. И сооооовсем чуть-чуть про [xdg](https://en.wikipedia.org/wiki/Freedesktop.org).
* Ознакомиться с форматом [yaml](https://ru.wikipedia.org/wiki/YAML).
* Красивый вывод тудушек сделать с использованием yeild.
* [Изучить](https://towardsdatascience.com/format-function-in-python-98ed34e0a70e), как работает функция format. [Сайт](https://pyformat.info/) с примерами работы format.
* Изучить виды параметров в Python (позиционные, чисто именованные). Книга Python К вершинам мастерства, стр. 180-182.
* Очень [важная статья](https://realpython.com/python-import/) про пакеты и импорты в питоне. Как устроены пакеты, как правильно делать импорты в питоне, зачем нужен \_\_init\_\_, зачем нужен флаг -m, когда запускаем скрипт.
* [Статья](https://habr.com/en/company/lamoda/blog/432656/) по аннотации типов. [Best Practices.](https://docs.python.org/3/howto/annotations.html)

Общая часть ДДЗ:

* должен быть реализован следующий сценарий: при запуске программы определить и считать конфиг файл. Если конфига нет, то нужно создать дефолтный. Если в конфиге уже есть путь до тудушки, то работаем с ней, если нет, то создать тудушку по умолчанию.
* реализовать возможность иметь несколько тудушек (в одном конфиге) любого вида. Если тудушек несколько то, при запуске программы первым параметром нужно указывать имя тудушки, к которой будет применены дальнейшие команды.
* реализовать возможность редактирования записей в тудушке (флаг --edit)
* в конфиг добавить редактор по умолчанию. на флаг --edit должен открываться редактор. В случвае если редактор не задан выводить соответствующее сообщение
* реализовать интерактивное удаление, то есть с флагом --delete нужно по очереди выводить тудушки и предлагать ее удалить
* реализовать модификацию конфига через CLI
* добавить возможность назначать время исполнения тудушки, и соответственно добавить в тудушку поле для хранения этой даты
* to be continued... **Рекомендуется** формализовать и структурировать задачи, не сразу кидаться писать код, а подумать о структуре, как правильно делать. И не забывайте сразу писать тесты. Хороший код - тесты писать не сложно и наоборот. Не бойтесь рефакторить и переписывать код.

## План (для преподавателя)

Выдать и объяснить концепцию ддз. 

## Рассматриваемые вопросы

1. git cherry pick
1. Конфигурационные файлы. Формат yaml.
1. Конструирование путей с помощью  path.join
1. Работа с константами.
1. Свои исключения.
1. **kwargs
1. str.format
1. Строки в многострочном виде  и textwrap
1. Аннотация типов

## Ход работы

1. **Совет дня.** Записывайте все. Любые задачи, которые получаете - все записывайте. Даже если противная сторона говорит что-то на словах и не хочет записывать, всегда записывайте для себя. Если идет разговор, делайте пометки, а потом все равно все пометки распишите подробнее. Можно показать результат противной стороне. Нет ничего хуже, чем то, что после обсуждения задач уйти довольными друг другом, но понявшими обсуждаемое по разному. Ваша цель убедиться, что у вас с противной стороной одно и тоже понимание вещей.

2. На дом было задано реализовать конфигурационный файл. Зачем это нужно было обсуждено ранее.  Конфиги нужны часто, конфиги нужны много, разберемся, как это сделать правильно.

   **Очередной раз создадим ишью, создадим ветку.** 

   **Из прошлого ДЗ**: нужно было поправить двойное использование функции _parse. У нас сейчас нет цели сделать это красиво, но дважды не хотим вызывать. 

   Получится примерно так: 

   ```python
   def __init__(self, path_todo):
       self.path_todo = path_todo
       # todo отрефакторить двойной вызов _parse (поменять структуру возвращаемых данных?)
       todo = self._parse()
       self.name = todo["name"]
       self.entries = todo["todos"]
   ```

   По ходу дела поправили старую задачку. Тут самое время запустить ваши тесты, чтобы понять, что ничего не сомалось. Потому что такие безобидные изменения даже в нашей небольшой программе могут что-то незаметно сломать. Всопмним хоть случай, когда переименовывали entities в entries. Заработало не сразу, хотя изменения кажется были безобидными. И тесты тут очень спасают. 

   Насчет создания ветки для данной задачи. В целом нет ничего плохого создать отдельную задачу. Но как писал в прошлом ПЗ, если решение задачи занимает умозрительно не более минуты, новых тестов писать не нужно и старые тесты не падают, то ветку создавать не обязательно. А в ишью, которое вероятно создано, можно просто указать там номер коммита и смело его закрыть.

   Вернемся к конфигам. 

   Мы уже знакомы c текстовым форматом данных - json. Сегодня познакомимся еще с одним форматом, который очень распространен (например, docker, gitlab ci) для написания конфигов - yaml. Пока все, что нам нужно - хранить путь, до существующих тулушек. Пока что в нашем случае еще проще - до одной тудушки.

   Создадим файл config.py, где будем реализовывать все необходимые обработки конфига.

   И конфиг, который будет иметь примерно следующее содержание:

   `todo_journal: /home/user/projects/python-project/tests/data/test_todo `

   Какие функции нам нужны сразу?

   * загрузка конфига (откуда?) Где у нас лежит конфиг? Как определять до него путь? Как это реализовать и где будем это реализовывать?
   * парсинг конфига

   Воспользуемся так называемым xdg  BaseDirectory.

   Получим следующий код:

   ```python
   # config.py
   import os
   import yaml
   import xdg.BaseDirectory
   
   
   def load_config(config_path):
       """
       Загружаем конфигурационный файл тудушки
       :param config_path: путь до конфига
       :return:
       """
       with open(config_path, encoding='utf-8') as f:
           # SafeLoader используется, когда источник неизвестен
           return yaml.load(f, Loader=yaml.SafeLoader)
   
   
   def get_config_path():
       try:
           config_directory_path = xdg.BaseDirectory.save_config_path("todo")
       except FileExistsError:
           raise Exception(f"No config file todo_config.yaml")
   
       return os.path.join(
           config_directory_path, "todo_config.yaml"
       )
   ```

   ```python
   #todo.py
   
   from src.config import get_config_path, load_config
   
   def run(args):
       # TODO нужно поправить вызовет ошибку. так как не создано. дома необходимо реализовать дефолтное местоположение и предложить ввести свое.
       config_path = get_config_path()
       config = load_config(config_path)
       todo = TodoJournal(config)
       # ...
   ```

   ```python
   # todo_journal.py
   
   class TodoJournal:
       def __init__(self, config):
           self.path_todo = config["todo_journal"]
           # todo отрефакторить двойной вызов _parse (поменять структуру возвращаемых данных?)
           todo = self._parse()
           self.name = todo["name"]
           self.entries = todo["todos"]
   ```

   Вернемся к config.py

   `"todo_config.yaml", "todo"` - все это константы. Более того - это константы, которые могут пригодиться в нескольких местах. Где-то можно ошибиться, захотите изменить название - нужно будет по всему проекту лазить искать, где они используются. 

   Поэтому очень важно константы выносить, как глобальные переменные. Либо в начало файла, если константы нужны только в этом файле, либо в отдельный файл, если нужны во всем проекте.

   ```python
   # config.py
   XDG_RESOURCE = "todo"
   DEFAULT_CONFIG_NAME = "todo_config.yaml"
   ```

1. **cherry pick** - бывают случаи, когда в текущую ветку из другой ветки хочется взять всего один коммит. То есть хочется не мерджить две ветки, а взять только вот один кусочек кода - один коммит.

   Например, сейчас мы реализовали рефакторинг кода в конструкторе. В этой ветке мы же работаем над конфигом, и пока не закончили.  Однако этот рефакторинг хорошо бы уже иметь в мастере. Для этого и есть замечательная команда c сочным названием cherry pick. 

   Переходим в  master и черипикаем нужный нам коммит - коммит, убирающий двойное использование _parse.

1. Вернемся к коду с конфиг файлами. Мы делаем `raise Exception`.

   Отдельно стоит отметить, что ловить или вызывать общее исключение - очень неправильная практика. То есть избегайте кода вида:

   ```python
   try:
   	pass
   except Exception:
   	pass
   # или
   # ..some code
   raise Exception
   ```
   
   На подобный код также будет ругаться и пайлинт.
   
   При работе с тудушкой (и с любой более менее большой программой) могут возникнуть случаи, когда базового набора исключений не хватает и хочется рэйзить свои исключения, как-то по особому выводящие ошибку или как-то по особому обрабатываемые.
   
   Создадим файл exception.py и реализуем свой класс исключений. 

   Общий вид будет следующим:

   ```python
   class TodoJournalError(Exception):
       def __init__(self, error_type, **kwargs):
           self.error_type = error_type
           self.message = self._get_error_messages(**kwargs)
   
       def _get_error_messages(self, **kwargs):
           pass
   ```
   
   То есть нам нужен конструктор с полем, где будет содержаться код ошибки и поле с текстом исключения. Текст исключения мы хотим формировать в зависимости от кода ошибки, а также в текст ошибки мы хотим передавать некоторые параметры (причем в разных ошибках - разные параметры. именно поэтому пользуемся **kwargs)
   
   Функция _get_error_message имеет следующий вид:
   
   ```python
   def _get_error_messages(self, **kwargs):
       error_messages = {
           "ConfigDirectoryIsFile": """
                   Путь до каталога с конфигом является файлом
   
                    {config_directory_path}
   
                    Удалите файл или укажите другой путь до конфигруационного файла.
               """,
           "TodoJournalFormatError": """
                   Ошибка в формате файла: 
   
                   Имя журнала: {journal name}
   
                   Путь до журнала: {journal_path}
                """
       }
   
       msg = error_messages[self.error_type].format(**kwargs)
       msg = textwrap.dedent(msg)
       return msg
   ```
   
   Обратите внимание на применение пакета textwrap, который позволяет форматировать и представлять в удобном виде выводимый текст.
   
   А функция get_config_path будет иметь следующий вид:
   
   ```python
   def get_config_path():
       try:
           config_directory_path = xdg.BaseDirectory.save_config_path(XDG_RESOURCE)
       except FileExistsError:
           raise TodoJournalError("ConfigDirectoryIsFile",
                                  config_directory_path=os.path.join(xdg.BaseDirectory.xdg_config_home, XDG_RESOURCE), )
   ```
   
   Попробуем запустить так код. Попробуем запустить его с отладкой. Видим, что исключение которое мы вызываем перехватывается выше  в функции main.  Там мы ловим общее исключение и даже есть пометка реализовать свое исключение, так как ловить общее исключение неправильно. 
   
   А как нам нужно? Нам нужно вызвать свое исключение (что мы сделали выше) и поймать именно его, поэтому код в функции main будет выглядеть следующим образом:
   
   ```python
   def main():
       try:
           cli_args = sys.argv[1:]
           # 1. Спарсить аргументы командной строки
           args = parse_args(cli_args)
           print(args)
           # 2. вызвать соответствующие функции
           return run(args)
       except TodoJournalError as e:
           # TODO Создать свое исключение для обработки такой ситуации
           print(e.message)
           return 1
   ```

5. Python - язык с динамической типизацией и позволяет гибко оперировать переменными различных типов. Однако, если на вход функция принимает словарь и обработка входного параметра делается исходя из того, что это словарь, то получив на вход множество возникнет исключение. В других случаях при написании кода все равно мы держим в голове тип данных, который будет использоваться. 

   С версии 3.6 в python появилась аннотация типов. Использование аннотаций не приведет к ошибкам интерпретатора. В основном это нужно для сторонних пакетов, использующих ваш код и статических анализаторов кода.

   С появлением аннотаций признаком хорошего кода стало их использование. Рассмотрим несколько базовых, часто встремающихся случаев, когда можно легко применить аннотации.
   
   Начнем класса TodoJournal.  Функция _parse. Тут особенно важно, какой формат она умеет парсить и в каком формате возвращает значения. 
   
   Хорошей практикой является использование встроенного модуля typing, который предоставляет более расширенные возомжонсти для типизирования.
   
   Например, можно указать, что функция parse возвращает dict, а модуль  typing позволяет еще конкретизировать, сожержимое словаря. Причем отдельно можно аннотируется ключ и значение.
   
   Таким образом _parse:
   
   ```python
   def _parse(self) -> Dict[str, str]:
   ```
   
   Аналогично аннотируются списки и кортежи.
   
   Есть еще один интересный момент в этой функции. В одном из случаем он делает sys.exit, то есть не возвращает управление, а просто кидает исключение. В таких случаях используется аннотация NoReturn. 
   
   А для того, чтобы указать несколько возможных возвращаемых типов необходимо использовать конструкцию Union и окончательный вариант объявления функции будет следующим:
   
   ```python
   def _parse(self) -> Union[Dict[str, str], NoReturn]:
   ```
   
   Бывают случаи, когда нам в целом все равно какой тип данных подавать. Например функция add_entry. В целом мы можем записать любой объект. Но чтобы это не выглядело, как будто мы забыли про аннотацию используют Any. А когда функция ничего не возвращает, то указывается None
   
   ```python
   def add_entry(self, new_entry: Any) -> None:
   ```
   
   Теперь перейдем к аннотации полей класса:
   
   ```python
   class TodoJournal:
       path_todo: str
       name: str
       entries: List[Any]
   ```
   
   Можно сделать аннотацию для итератора: 
   
   ```python
   def __iter__(self) -> Iterator:
   ```
   
   Таким образом мы научились аннотировать:
   
   * коллекции с конкретизацией типов данных внутри;
   * функции не возвращающие управление;
   * функции без возвращаемых значений;
   * случаи, когда подходит несколько типов;
   * аннотация полей класса.
   
   

