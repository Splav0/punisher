### Условия решения:

* можно использовать любой материал, принесённый с собой (книги, статьи, код)
* проверяются разные знания, как то, чтомы проходили на ПЗ, так и то что было дано в качестве домашнего задания
* необходимо вести разработку с применением СКВ git: в частности используя систему веток и механизм issues в gitlab; должен быть хотя бы один merge-request
* в процессе выполнения работы быть готовым продемонстрировать навыки работы с git через cli (выполнить merge с конфликтами)
* необходимо использовать статический анализатор кода pylint (код должен бьть оценён на 10)
* все модули, классы, функции, методы должны быть задокументированы в любом стиле docstrings
* весь код должен быть покрыт тестами (минимальное покрытие тестами - 85%); ненаписанные тесты => автоматическое выставление незачтено
* в README.md проекта должны быть инструкции по запуску Вашего кода, а также тестов с измеренем степени покрытия (из терминала)
* код не должен быть написан единой портянкой
* запрещено использование мобильных телефонов и любой другой незарегистрированной техники (выявление факта списывания грозит выставлением обоим негодяям незачтено)

### Структура репозитория

* файл `coordinates.py`, содержащий реализацию задания
* файл `tests.py`, содержащий тесты к написанному коду
* файл `.gitignore`
* файл `README.md`, содержащий инструкции по запуску написанного кода, линтера и тестов

### Задание на зачёт

Необходимо реализовать класс, воспроизводящий координатную четверть на плоскости в декартовом пространстве

Шаблон класса представлен ниже:
```python
class CoordinatesQuarter:
    def __init__(self, quarter_number: str):
        self._quarter_number = ...
        self._points = ...

    def __iter__(self) -> tuple:
        """
        Итератор по точкам четверти в обратном порядке
        @return: tuple, - координаты точки
        """
        pass

    def append(self, coordinates: tuple):
        """
        Добавление точки к внутреннему списку точек четверти _points
        @param coordinates: tuple, - координаты точки по осям абсцисс и ординат
        """
        pass

    @staticmethod
    def analyze_point(coordinates: list) -> tuple:
        """
        Анализ корректности координат точки и конвертирование их в нужный формат
        @param coordinates: list, - координаты точки из файла
        @raises AttributeError в случае, если координат больше 2
        @raises ValueError в случае, если нельзя определить вещественное число
            как с разделителем-точкой, так и с разделителем-запятой
        @return: tuple, - корректные координаты точки
        """
        pass

    @staticmethod
    def count_points_from_csv(path_to_csv: str, quarter: 'CoordinatesQuarter') -> int:
        """
        Подсчёт вхождения точек из входного csv-файла в указанную координатную четверть
            с добавлением подходящих считанных точек во внутренний список _points
        @param path_to_csv: str, - путь до входного csv-файла
        @param quarter: CoordinatesQuarter, - координатная четверть
        @return: int, - количество считанных точек координатной четверти
        """
        pass

    def get_points_squares(self) -> list:
        """
        Получение отсортированного по убывания списка площадей прямоугольников,
            построенных на точках четверти, входящих в список _points
        @return: list, - список площадей
        """
        pass
```

Для выполнения задания требуется, чтобы были реализованы следующие возможности:
1. создание координатной четверти с помощью конструктора нужно реализовать и арабскими, и римскими числами; в случае невозможности конвертирования номера координатной четверти необходимо генерировать исключение **KeyError**
2. у созданного экземпляра класса должно быть 2 внутренних атрибута: **_quarter_number** (целое число - тип `int`) и **_points** (список - тип `list`)
```bash
>>> quarter_by_arabic = CoordinatesQuarter('1')
>>> quarter_by_roman = CoordinatesQuarter('III')
```
3. нужно реализовать возможность проверять включение точки, определённой координатами, в указанную четверть
```bash
>>> (1.2, 2.4) in quarter_by_arabic
True
```
4. нужно реализовать возможность итерироваться по точкам координатной четверти в обратном порядке по точкам четверти, лежащим в **_points**
```bash
>>> for point in quarter_by_arabic:
...     ...
```
5. нужно реализовать метод **append**, добавляющий точку по переданным в кортеже координатам во внутренний список **_points** в случае, если точка принадлежит координатной четверти
```bash
>>> quarter_by_arabic.append((2.5, -3.1))
```
6. нужно реализовать метод **count_points_from_csv** для подсчёта точек, принадлежащих указанной четверти, координаты которых считаны из входного csv-файла
```bash
>>> quantity_of_good_points = CoordinatesQuarter('/path/to/csv/with/3/good/points', quarter_by_arabic):
>>> print(f'количество подходящих точек: {quantity_of_good_points}')
3
```
7. нужно реализовать метод **analyze_point** для получения корректных координат точки, считанной из csv-файла (разделителем координат является символ `;`, разделителем дробной части - символы `.` или `,`); в случае, если невозможно конвертировать считанную координату в вещественном виде, генерировать исключение ValueError; в случае, если коордита в строке входного файла не 2, генерировать исключение AttributeError
8. нужно реализовать метод **get_points_squares** для подсчёта площадей прямоугольников, построенных на каждой точке четверти из внутреннего списка **_points**, и возвращения их списка по убыванию значений

### Комментарии

Пункт 8 задания состоит в том, чтобы получить список площадей прямоугольников, построенных на всех точках, содержащихся во внутреннем списке **_points**, по убыванию их величины

Пусть Вы создали экземпляр класса `CoordinatesQuarter` с параметров `III`, указывая на инициализацию 3-ей четверти координатной плоскости в декартовом пространстве. Далее с использованием метода `append` добавили туда 3 точки в следующей последовательности (приведём далее их координаты в кортеже): `(-1, -1)`, `(-10, -3)`, `(-2, -5)`. После выполнения этой операции внутренний список **_points** содержит 3 кортежа в указанной последовательности.

После дальнейшего применения метода **get_points_squares** Вы должны получить следующий список - `[30, 10, 1]`, соответствующий площадям фигур, построенных с использованием указанных точек и начала координат (очевидная точка `(0, 0)`)