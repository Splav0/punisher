# Зачёт

Пока грузится виртуальная машина, проходим анонимный [опрос](http://gitwork.ru:5000/python/python-end?pin=4944)

#### Навигация
- [условия][conditions]
- [ход работы][progress]
- [формулировка задачи][task]
   * [задание 1][task-1] - скрипт для работы с CSV-файлами
      * режим [визуализации][task-1-mode-1] данных
      * режим [суммирования][task-1-mode-2] данных
   * [задание 2][task-2] - скрипт для работы с однострочным файлом
   * [задание 3][task-3] - скрипт для работы с многострочным файлом
***

#### Условия:

* можно использовать любой материал, принесённый с собой (книги, статьи, код)
* проверяются разные знания, как то, чтомы проходили на ПЗ, так и то что было дано в качестве домашнего задания
* необходимо вести разработку с применением СКВ **git**: в частности используя систему веток и механизм issues в gitlab; должен быть хотя бы один merge-request
* в процессе выполнения работы быть готовым продемонстрировать навыки работы с **git** через *cli* (выполнить merge с конфликтами)
* необходимо использовать статический анализатор кода **pylint** (код должен бьть оценён на 10)
* все модули, классы, функции, методы должны быть задокументированы в любом стиле **docstrings**
* весь код должен быть покрыт тестами (минимальное покрытие тестами - **85%**); ненаписанные тесты => автоматическое выставление **незачтено**
* в **README.md** проекта должны быть инструкции по запуску Вашего кода, а также тестов с измеренем степени покрытия (из терминала)
* код не должен быть написан единой портянкой
* **запрещено** использование мобильных телефонов и любой другой незарегистрированной техники
* выявление факта списывания грозит выставлением обоим негодяям **незачтено**
***

#### Ход работы:

1. создать приватный репозиторий с названием **python-exam**
2. добавить пользователей **anetto** и **yar_av** с ролью _maintainer_
3. декомпозировать задачу на более мелкие подзадачи и внести задачи в issues
   * в каждой issue расписать, какие функции у вас будут, что они будут принимать и возвращать
   * при выполнении конкретной issue связать её с веткой, в которой она решается
4. после реализации функции сразу приступить к написанию тестов и проверке кода в pylint
***

#### Формулировка задачи

##### 1. Скрипт для работы с CSV-файлами

Скрипт должен содержать реализацию класса **ReadCSV** ("считанный CSV-файл"), шаблон оформления которого приведён ниже:

```python
class ReadCSV:
    def __init__(self,
                 filename: str):
        """Конструктор класса ReadCSV, построчно считывающий исходный файл
        @param filename: str, - путь до исходного CSV-файла
        @raises RuntimeError в случае проблем с чтением исходного файла
        @raises BufferError с выводом сообщения 'no rows in CSV' в случае, если исходный файл пуст

        Объект класса должен иметь 2 атрибута
        - _rows: list, - список считанных строк исходного файла
        - is_summable: bool, - индикатор суммируемости исходного файла
            == True, если исходный CSV-файл состоит из только 1-го столбца,
                     причём содержит только целые числа
            == False, во всех остальных ситуациях

        В случае, если возникают проблемы с чтением исходного CSV-файла, требуется генерировать
        исключение RuntimeError
        В случае отсутствия строк в исходном файле, требуется генерировать исключение BufferError
        с сообщением 'no rows in CSV'

        Допускается хранение значений в списке _rows как в строковом формате, так и
        в уже конвертированном формате целых чисел в случае, если это возможно

        ВАЖНО отметить, что в считываемых строках исходного CSV-файла требуется обрезать начальные
        и конечные пробельные символы 
        """
        pass

    def __getitem__(self,
                    index: int) -> str:
        """Оператор индексирования по строкам исходного CSV-файла
        @param index: int, - индекс строки в исходном CSV-файле
        @return: str, - искомая строка из входного CSV-файла
        """
        pass

    def __add__(self, other):
        """Оператор сложения 2-х суммируемых (значение True у атрибута is_summable) CSV-файлов
        @param other: ReadCSV, - объект класса ReadCSV (считанный CSV-файл)
        @return: ReadCSV, - объект класса ReadCSV, представляющий собой сумму 2-х CSV-файлов
        @raises ArithmeticError с текстом 'can't summarize non-summable files' в случае,
            если сложить 2 исходных CSV-файла корректно нельзя (хотя бы один из них не-суммируемый)

        Результатом сложения 2-х суммируемых CSV-файлов является объект класса ReadCSV,
        длина атрибута _rows которого равна наименьшей длине атрибута _rows у складываемых файлов,
        а значения на соответствующих позициях равны сумме значений на тех же позициях
        в исходных файлах, т.е. чтобы получить 2-ой элемент атрибута _rows результирующего объекта,
        требуется сложить 2-ой элемент атрибута _rows объектов self и other
        В случае, если один из файлов не является суммируемым, генерировать
        исключение ArithmeticError с текстом 'can't summarize non-summable files'
        """
        pass

    def get_value(self,
                  row_index: int,
                  column_index: int) -> str:
        """Получение строкового значения в соответствующей ячейке входного CSV-файла
        @param row_index: int, - индекс строки CSV-файла
        @param column_index: int, - индекс столбца CSV-файла
        @return: str, - строковое значение в соответствующей ячейке
        @raises: RuntimeError в случае ошибок индексирования ячейки
        @raises: RuntimeError в случае отсутствия парных закрывающихся двойных ковычек

        Для получения значения ячейки в соответствующей строке исходного CSV-файла требуется
        разбить её с учётом того, что разделителем является символ ';'

        В случае ошибок индексирования по строкам или столбцам исходного CSV-файла
        генерировать исключение RuntimeError

        В строке могут присутствовать двойные кавычки: подстрока, обрамлённое с 2-х сторон
        двойными кавычками (символ ") должно интерпретироваться как одно значение
        В случае, если в строке для какой-то из открывающихся двойных ковычек отсутствует
        её закрывающаяся пара, генерировать исключение RuntimeError
        """
        pass
``` 

Также скрипт должен содержать реализацию 3-х дополнительных функций:

```python
import argparse


def parse_cmd_args(cmd_args: list) -> argparse.Namespace:
    """Разбор аргументов командной строки
    @param cmd_args: list, - список аргументов командной строки
    @return: argparse.Namespace, -
        subparser_name: str, - название режима работы скрипта ("визуализация" или "суммирование")
            - visualize:
                csv_filename: str, - путь до исходного CSV-файла
                rows_quantity: int, - ограничение на количество выводимых строк исходного CSV-файла
            - summarize:
                csv_filenames: list, - список путей до суммируемых CSV-файлов
    """
    pass


def summarize_csvs(csv_filenames: list) -> list:
    """Суммирование целочисленных значений единственного столбца входных CSV-файлов
    @param csv_filenames: list, - список путей до CSV-файлов (хотя бы 1)
    @return: list, - список целых чисел с результатом сложения 1-го столбца CSV-файлов
    """
    pass


def visualize_csv(csv_filename: str,
                  rows_quantity: int) -> None:
    """Визуализация данных из входного CSV-файла
    @param csv_filename: str, - путь до CSV-файла
    @param rows_quantity: int, - количество строк для чтения из входного файла

    При выводе информации о строке в формате, представленном ниже, требуется учитывать,
    что первая и последняя ковычки необходимы только для демонстрации границ считанной строки
    """
    pass
```

Скрипт также должен уметь разбирать аргументы командной строки (предполагаемое имя функции для выполнения этой задачи: `parse_cmd_args`) с использованием инструментария python-модуля **argparse**

Скрипт должен уметь работать в 2-х режимах:
* **визуализация** элементов в исходном CSV-файле (вывести на экран информацию по каждой строке исходного файла, отметив при этом каждое отдельное значение из столбцов), предполагаемая команда для режима - `visualize`
* **суммирование** соответствующих элементов во входных CSV-файлах (в случае, если исходные CSV-файлы состоят из одного столбца целых чисел, необходимо позволять строить новый объект, состоящий из одного столбца, значения которого построены по принципу суммирования соответствующих элементов из всех исходных файлов), предполагаемая команда для режима - `summarize`
***

###### Визуализация данных исходного CSV-файла

В режиме **визуализации** на вход скрипта поступает 2 обязательных параметра:
* путь до читаемого CSV-файла (строковое значение), переданный через флаг `-p` или `--path-to-csv`
* ограничение на количество считанных строк для вывода на экран (целое значение), переданное через флаг `-r` или `--rows-quantity`

После очевидного чтения данных из файла вывод информации должен быть оформлен в следующем формате:
* для каждой строки исходного файла, проходящей по количественному ограничению, поданному на входе скрипта, необходимо вывести в первой строке информацию по шаблону `row {номер-строки}: "{сама-строка-файла}"` (важно отметить, что нумерация в выводе должна вестись с 1)
* в следующих строках после вывода информции о самой строке необходимо привести значения всех столбцов строки с учётом символа табляции перед ним по шаблону `\t{значение-столбца}`

Пример вывода информации в терминал командной строки для 2-ой строки предполагаемого исходного CSV-файла (напомним, что первая и последняя ковычки в первой строке вывода несут лишь ограничительную функцию):
```bash
...
row 2: "word_1;"word_2;word_3";word_4;"word5;word6";word7"
    word_1
    word_2;word_3
    word_4
    word_5;word_6
    word_7
...
```

Формат запуска скрипта в режиме **визуализации**: `python3 work_with_csv visualize -p path/to/file.csv -r 2`

Пример входного CSV-файла для инструкции выше:
```text
1;2;3
a;"b;c;d,e";f
g;h;i;j
```

Ожидаемый вывод:
```text
row 1: "1;2;3"
    1
    2
    3
row 2: "a;"b;c;d,e";f"
    a
    b;c;d,e
    f
```

Предполагается, что реализация конкретного режима работы скрипта в режиме **визуализации** будет представлена в отдельной функции с названием `visualize_csv`, принимающей на вход 2 параметра: путь до читаемого CSV-файла и ограничение на количество считанных строк для вывода на экран 
***

###### Суммирование исходных CSV-файлов

В режиме **суммирования** на вход скрипта поступает список исходных CSV-файлов (их количество строго _положительное_)

В ходе выполнения скрипта в указанном режиме требуется для каждого файла последовательно:
* считывать из него данные
* анализировать на то, является ли файл суммируемым
* складывать с уже накопленным результатом

Результатом работы скрипта в режиме **суммирования** является список целых чисел - количество которых совпадает с наименьшей длиной списка строк среди всех исходных CSV-файлов. Элементами этого списка являются суммы соответствующих элементов строк всех исходных CSV-файлов

Формат запуска скрипта в режиме **суммирования**: `python3 work_with_csv summarize path/to/first.csv path/to/second.csv path/to/third.csv`

Пример входных CSV-файлов для инструкции выше:
```text
# файл path/to/first.csv
1
2
3

# файл path/to/second.csv
2
2
2
2

# файл path/to/third.csv
5
4
3
2
1
```

Ожидаемый результат (ожидаемое значение списка строк результирующего объекта):
```python
[8, 8, 8]
```

Предполагается, что реализация конкретного режима работы скрипта в режиме **суммирования** будет представлена в отдельной функции с названием `summarize_csvs`, принимающей на вход 1 параметр: список путей до исходных CSV-файлов, которые нужно суммировать
***


Итого в вашем проекте должны быть
* work\_with\_csv.py
* tests.py
* README.md
* .gitignore

##### 2. Скрипт для работы с однострочным файлом

Скрипт должен содержать реализацию класса **Setter**, шаблон оформления которого приведён ниже:

```python
class Setter():
    """Класс для работы со строкой из множества слов"""
    def __init__(self, filepath):
        """Открыть filepath на чтение, считать и сохранить первую строку.
        Дальше весь класс работает с этой считанной строкой.
        Строка - набор слов, разделённых пробельными символами.
        Args:
            filepath - путь к файлу
        Raises:
            ValueError - если первая строка содержит только пробельные символы
            RuntimeError - если filepath - каталог или нет прав
        Side effects:
            Создаёт пустой файл filepath, если его не было

        для примера в файле такая первая строка
        мы   короли ночной вероны мыы короли
        """
        pass

    def __len__(self):
        """
        Returns: число слов в считанной строке

        Для нашего примера вернёт 6
        """
        pass

    def __iter__(self):
        """
        Итератор по всем словам считанной строки

        Для нашего примера итератор вернёт (за 6 обращений)
        мы
        короли
        ночной
        вероны
        мыы
        короли
        """
        pass

    def shout(self, count=3):
        """
        Функция-генератор, итерируется по всем словам
        Слова длиной меньше или равными count нужно выводить ЗАГЛАВНЫМИ буквами
        Args:
            count - длина строки, по умолчанию 3
        Raises:
            ValueError - если count меньше или равно нулю
            RuntimeError - если count не число

        Для нашего примера и count=3 вернёт за 6 обращений
        МЫ
        короли
        ночной
        вероны
        МЫЫ
        короли
        """
        pass

    def only_one(self):
        """
        Returns:
            словарь, где ключ - это уникальные слова из считанной строки,
            значения - число символов в этом слове

        Для нашего примера вернёт
        {'мы': 2, 'ночной': 6, 'короли': 6, 'вероны': 6, 'мыы': 3}
        """
        pass
```

Итого в вашем проекте должны быть
* setter.py
* main.py (опционально)
* tests.py
* README.md
* .gitignore


##### 3. Скрипт для работы с многострочным файлом

Скрипт должен содержать реализацию класса **Getter**, шаблон оформления которого приведён ниже:

```python
class Getter():
    """Класс для работы со файлом из множества строк, внутри каждой строки множество слов"""
    def __init__(self, filepath):
        """Открыть filepath на чтение, считать и сохранить все строки.
        Дальше весь класс работает со считанными строками.
        Каждая строка - набор слов, разделённых пробельными символами.
        Начальные и конечные пробельные символы удалять.
        Args:
            filepath - путь к файлу
        Raises:
            ValueError - если есть хотя бы одна строка, которая содержит только пробельные символы
            RuntimeError - если на filepath нет прав
            IsADirectoryError - если filepath - каталог
        Side effects:
            Создаёт файл filepath, если его не было

        для примера в файле текст

        мы   короли ночной вероны
        мыы короли
        """
	pass

    def __len__(self):
        """
        Returns: число слов в самой длинной строке

        Для нашего примера вернёт 4 (длина нулевой, самой длинной строки)
        """
	pass

    def __iter__(self):
        """
        Итератор по всем словам всего считанного файла

        Для нашего примера итератор вернёт (за 6 обращений)
        мы
        короли
        ночной
        вероны
        мыы
        короли
        """
	pass

    def walk(self, step=2):
        """
        Функция-генератор, итерируется по словам считанного файла с заданным шагом
        Args:
            step - размер шага, по умолчанию 2. Может быть любым типом данных
        Raises:
            ValueError - если step меньше или равно нулю
            RuntimeError - если step не может быть приведено к числу

        При step=1 ведёт себя аналогично итератору.
        Для нашего примера и step=2 вернёт за 3 обращения
        мы
        ночной
        мыы

        То есть начинать с нулевого слова и возвращать каждое step слово
        """
	pass

    def get_word(self, row, col):
        """
        Возвращает слово [row][col], как из двумерного массива
        Args:
            row - номер строки
            col - номер столбца
        Returns:
            слово из row строки и col столбца, нумерация с 0
        Raises:
            IndexError, если такой строки или столбца нет
            RuntimeError, если аргументы отрицательные или не могут быть числом

        Для нашего примера
        get_word(0, 0) == "мы"
        get_word(0, 2) == "ночной"
        get_word(1, 1) == "короли"
        """
	pass

    def popular(self):
        """
        Возвращает число слов в самой длинной строке

        Для нашего примера вернёт 4 - число слов в самой длинной, нулевой строке
        """
	pass

    def long(self):
        """
        Возвращает словарь, где ключи - строки (с обрезанными по краям пробелами), а значения - число слов в этой строке

        Для нашего примера это
        {"мы   короли ночной вероны": 4, "мыы короли": 2}
        """
	pass
```
Итого в вашем проекте должны быть
* getter.py
* main.py (опционально)
* tests.py
* README.md
* .gitignore

[conditions]: #условия
[progress]: #ход-работы
[task]: #формулировка-задачи

[task-1]: #1-скрипт-для-работы-с-csv-файлами
[task-1-mode-1]: #визуализация-данных-исходного-csv-файла
[task-1-mode-2]: #суммирование-исходных-csv-файлов
[task-2]: #2-скрипт-для-работы-с-однострочным-файлом
[task-3]: #3-скрипт-для-работы-с-многострочным-файлом
