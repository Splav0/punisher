# ПЗ6 - todo

## Домашнее задание

* Проверить, что функции протестированы, пайлинт не ругается, все функции задокументированы
* Изучить [PEP 8](https://www.python.org/dev/peps/pep-0008/) (очень желательно в оригинале)
* Научиться применять git stash в командной строке
* Прочитать [сравнительный обзор](https://habr.com/en/post/466999/) библиотек для написания cli. Очень рекомендуется прочитать также комментарии. В них можно сразу узнать какие-то use case от тех, кто этим пользуется, а также альтернативные точки зрения.
* Изучить применяемые в пз функции пакета argparse
* Выполнить все задания, которые описаны тексте ПЗ.
* Протестировать все написанные функции.

## Рассматриваемые вопросы

* command line interface (cli)
* Библиотеки для cli
* git stash
* PEP
* readme

## Ход работы

### Обсуждение

Какие проблемы, вопросы?

Любую задачу выполнять следующим образом:

1. Создать для задачи issue.
2. Создать для задачи ветку.
3. Выполнить задачу. В процессе выполнения задачи делать коммиты, по завершении каждой логической мини-подзадачи.
4. В процессе решения задачи и появления новых функций **сразу** писать к ним тесты. Если задача - исправление бага, то покрыть тестами эту ситуацию.
5. Перед отправкой результатов на сервер запустить pylint и исправить все замечания. (Сделать коммит pylint refactoring).
6. Сделать push результатов на сервер.

Если обнаружился баг:

1. Постараться локализовать его. 
2. Если локализация и исправление заняло больше минуты. Создать задачу (issue), описывающую баг. Чем подробнее вы опишите проблему, тем лучше. Хоть сочинение пишите, но чтобы было понятно, как этот баг воспроизвести.
2. Создать ветку. Исправить баг. Покрыть тестами данный случай.
3. По результатам исправления в ишью описать то, как была решена проблема. Также - чем подробнее тем лучше. Хоть сочинение пишите. 
4. Смерджить ветки. Закрыть ишью. 


### CLI

Обсудим логику работы. Будет условно два режима: режим **создания нового** и режим **просмотра и редактирования** существующего.

Если мы не указываем никаких аргументов (начинающихся с '-' или  '--'), то по умолчанию будем находиться в режиме создания.

1. Вынесем функцию main в отдельный файл.

   В этой функции необходимо спарсить аргументы командной строки, обработать и выполнить соответствующие команды.

   ```python
   from src.TodoJournal import TodoJournal
   
   
   def main():
       try:
           # 1. Спарсить аргументы командной 
           cli_args = sys.argv[1:]
           # 2. обработать аргументы командной строки
           args = parse_args(cli_args)
           # 2. вызвать соответствующие функции
           return run(args)
       except Exception as e:
           # TODO Создать свое исключение для обработки такой ситуцации (будем обсуждать на следующих пз)
           print(e)
           return 1
   ```

2. Возникают ситуации, когда в процессе написания кода нужно вернуться к другому коммиту, что-то изменить, запушить. Например, ваш коллега сказал, что нужно срочно поправить баг в мастере, а у вас полным ходом идет работа над новой фичей. И тут хочется полложить текущие нарабтки "на стек", перейти к последнему коммиту в мастере, что-то поправить, запушить, а затем вернуться к текущей задаче.

   Для этого в git есть команда **stash**.

   Рефаторинг названий entities -> entries. Хотим чтобы к текущей рабочей версии были отрефакторены названия.

   Делаем stash. Переименовываем (Ctrl+H). Возвращаемся к наработкам.

3. Сделаем заглушки для функций `parse_args` и `run`.

   Создадим файлы `args.py`, где будет код, связанный с обработкой командной строки и `todo.py`, где будет функция запуска.

   Проверим, что программа корректно функционирует, а именно ничего не делает и не возникает ошибок. 

   Для запуска необходимо выполнить:

   ```bash
   python3 -m src.main 
   ```

   **#TODO**: Почему запустили так странно скрипт будем обсуждать на следующих ПЗ.

4. Как можно работать с аргументами командной строки

   Можно работать в лоб и анализировать массив `sys.argv` .

   Пример кода, как это может выглядеть (по сути так делали на ДДЗ по БОС):

   ```python
   import os
   import sys
   
   if len(sys.argv) > 2:
       print('Аргументов слишком много')
       sys.exit()
   
   if len(sys.argv) < 2:
       print('Аргументов слишком мало')
       sys.exit()
   
   input = sys.argv[1]
   
   if input == 'create':
       todo = TodoJournal(input)
   ```

   Получается очень громоздко, сложно понимать, сложно отлаживать, сложно расширять.

5. Есть встроенный пакет для этих целей argparse. 

   Реализуем функцию обработки параметров командной строки. На вход принимает спаршенные аргументы.

   ```python
   # файл args.py
   import argparse
   
   
   def parse_args(args):
       parser = argparse.ArgumentParser()
       composing = parser.add_argument_group("Writing new todos", "чтобы добавить новую запись в туду лист необходимо выполнить Х")
       composing.add_argument("text", metavar="", nargs="*")
       return parser.parse_intermixed_args(args)
   ```

   **Дома** разобраться с аргументами конструктора. Добавить formatter_class, add_help, description, epilog

   **Дома **Дома разобраться с аргументами add_argument

6. Реализуем функцию действия после обработки аргументов командной строки.

   Проблема в том, что сейчас у нас пока нет команды для открытия существующего журнала и нет команды создания нового журнала. Поэтому я просто сделаю хардкод. Как сделать так, чтобы программа помнила путь до тудушки?

   **Дома** реализовать конфиг файл, в котором будут храниться настройки тудушки. В нашем случае пока что только путь до тудушки. Важность хранения конфигурации отдельно от кода показана в [12 factor app](https://12factor.net/ru/config) - там представлена методология создания веб-приложений в виде SaaS. Другими словами - важные нюансы разработки больших приложений. 

   **Дома** реализовать команду создания журнала. Если такой журнал уже есть необходимо выводить соответствующее сообщение. Если журнал имеет некорректный формат, нужно выводить сообщение. Также предлагать создать тудушку где-то по умолчанию.

   ```python
   # файл todo.py
   from src.TodoJournal import TodoJournal
   
   
   def run(args):
       todo = TodoJournal("../tests/data/test_todo")
       if args.text:
           # todo.add_entry(args.text)
           raw_text = ''.join(args.text)
           todo.add_entry(raw_text)
   ```
    **Дома** пофиксить баг добавления тудушки без пробелов в файле todo.py
    **Дома** рефакторинг работы по индексам в файле todo.py
   Запустим и проверим, как работает наш CLI. Также можно вызвать --help.

7. Реализуем команду удаления записи по индексу.

   В parse_args допишем:

   ```python
       composing.add_argument("text", metavar="", nargs="*")
   
       standalone = parser.add_argument_group(
           "Standalone Commands",
           "После выполнения этих команд работы программа завершится",
       )
       standalone.add_argument(
           "--delete",
           dest="delete",
           help="Удаляет запись по индексу",
       )
   ```

   В run допишем:

   ```python
   if args.delete:
       todo.remove_entry(int(args.delete))
   ```

   Запустим и проверим работоспособность

   ```bash
   python3 -m src.main --delete 2
   ```

   **Дома** выводить удаляемую запись и спрашивать, действительно ли пользователь хочет удалить запись.

8. У нас есть тесты, есть уже работа через cli. Пора обсудить **readme**. Именно его видим в гитлабе, когда переходим к проекту.

   **Дома**: написать readme к своему проекту, где описать порядок запуска программы и тестов.

### PEP

До этого момента все знания о форматировании кода было основано на предыдущем опыте, на автоформатировании и на том, что выдает pylint (если не забывали пользоваться). На самом деле правила форматирования кода в Python формализованы в документе под названием PEP 8. 

Подобные документы публикуются на официальном сайте Python. Там же можно посмотреть составителей.

**Дома** необходимо изучить PEP8, в нем много полезной информации.

Не только правила форматирования и написания кода регламентируются подобным документом. Существует целый набор PEPов, регламентирующих различные аспекты, связанные с Python. Со списком всех PEPов можно ознакомиться в PEP0 на официальном сайте python.
